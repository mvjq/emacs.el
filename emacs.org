#+TITLE: Emacs.Org
*TIPS*:
- Use <C-c '> to eval the source block
- <l + TAB: opens a latex block
- <s + TAB: opens a source code block
- <q + TAB: opens a quotation block

* Configuration
*** Initialization
**** Personal info
	 Setting email and full name
#+BEGIN_SRC emacs-lisp
(setq user-full-name "M. Vinicius Junqueira"
      user-mail-address "codejunq@gmail.com")
#+END_SRC
**** Loading path and dirs
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/lisp")  ;;  all things lisp
  (add-to-list 'load-path "~/.emacs.d/lisp/code") ;; all things code
  (add-to-list 'load-path "~/.emacs.d/lisp/misc") ;; misc things
  (add-to-list 'load-path "~/.emacs.d/lisp/misc/use-package") ;; for use package
  (require 'use-package)
#+END_SRC
**** Package System
#+BEGIN_SRC emacs-lisp
  (when (>= emacs-major-version 24)
      (require 'package)
      (setq package-enable-at-startup nil)
      (setq package-archives '())
      (package-initialize)
      (add-to-list 'package-archives
                   '("melpa" . "http://melpa.milkbox.net/packages/") t)
      (add-to-list 'package-archives
                   '("gnu" . "http://elpa.gnu.org/packages/"))
      (add-to-list 'package-archives
                   '("org" . "http://orgmode.org/elpa/") t)
      (add-to-list 'package-archives
                   '("tromey" . "http://tromey.com/elpa/") t))
(require 'use-package)
(require 'diminish)                ;; if you use :diminishn
(require 'bind-key)                ;; bind-key

#+END_SRC

*** General Configuration
**** Org mode with Scratch
#+BEGIN_SRC emacs-lisp
(setq initial-major-mode 'org-mode)
#+END_SRC
**** Backup
#+BEGIN_SRC emacs-lisp
  (setq make-backup-files t ;; yep for backup
        backup-by-copying t ;;  backup though copying
        backup-directory-alist '(("." . "~/.backup/emacs")) ;; backup directory
        version-control t
        kept-new-versions 2
        kept-old-versions 4
        delete-old-versions -1
        vc-make-backup-files t)
#+END_SRC
**** Font lock
#+begin_src emacs-lisp
  (global-font-lock-mode 1) ;font lock everywhere
#+end_src
**** History
#+BEGIN_SRC emacs-lisp
(setq savehist-file "~/.emacs.d/backup/savehist")
(savehist-mode 1)
(setq history-length 10)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
	  '(kill-ring
		search-ring
		regexp-search-ring))
#+END_SRC
**** HELM
#+BEGIN_SRC emacs-lisp

	 ;;(add-to-list 'load-path "~/.emacs.d/elpa/helm")
	 ;;(add-to-list 'load-path "~/.emacs.d/lisp/helm/emacs-async")
		 ;; PACKAGE: helm-mode and helm-config
	 (use-package helm
	 :ensure t
	 :init
	 (when (executable-find "curl")
	   (setq helm-google-suggest-use-curl-p t))
	 (setq helm-split-window-in-side-p t ; open helm buffer inside current window, not occupy whole other window
		   helm-move-to-line-cycle-in-source t ; move to end or beginning of source when reaching top or bottom of source.
		   helm-ff-search-library-in-sexp t ; search for library in `require' and `declare-function' sexp.
		   helm-scroll-amount 8 ; scroll 8 lines other window using M-<next>/M-<prior>
		   helm-ff-file-name-history-use-recentf t
		   helm-M-x-fuzzy-match t ;; optional fuzzy matching for helm-M-x
		   helm-buffers-fuzzy-matching t
		   helm-recentf-fuzzy-match t
		   helm-apropos-fuzzy-match t
		   apropos-sort-by-scores t
		   helm-semantic-fuzzy-match t
		   helm-imenu-fuzzy-match t
		   helm-locate-fuzzy-match t
		   helm-lisp-fuzzy-completion t)
	 (helm-autoresize-mode t)
	 :config
	 (require 'helm-config)
	 ;; [#keybidings]
	 ;; global
	 ;; The default "C-x c" is quite close to "C-x C-c", which quits Emacs.
	 ;; Changed to "C-c h". Note: We must set "C-c h" globally, because we
	 ;; cannot change `helm-command-prefix-key' once `helm-config' is loaded.
	 (global-set-key (kbd "C-c h") 'helm-command-prefix)
	 (global-set-key (kbd "M-x") 'helm-M-x)
	 (global-set-key (kbd "M-y") 'helm-show-kill-ring)
	 (global-set-key (kbd "C-x b") 'helm-mini)
	 (global-set-key (kbd "C-x C-f") 'helm-find-files)
	 (global-set-key (kbd "C-h SPC") 'helm-all-mark-rings)
	 (global-set-key (kbd "C-c h x") 'helm-register)
	 (global-set-key (kbd "C-c h g") 'helm-google-suggest)
	 (global-set-key (kbd "C-c h M-:") 'helm-eval-expression-with-eldoc)
	 (global-set-key (kbd "C-c h o") 'helm-occur)
	 (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent actionev
	 (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB works in terminal
	 (define-key helm-map (kbd "C-z")  'helm-select-action); list actions using C-z
	 (add-to-list 'helm-sources-using-default-as-input 'helm-source-man-pages))
   ;; helm-eshell
	 ;;	 (use-package helm-eshell
	 ;;	 :ensure t
	 ;;	 :defer t
	 ;;	 :config
	 ;;	 (add-hook 'eshell-mode-hook
	 ;;			  #'(lambda ()
	 ;;				  (define-key eshell-mode-map (kbd "C-c C-l")  'helm-eshell-history)))
		  ;;bindings
	 ;;	 (define-key shell-mode-map (kbd "C-c C-l") 'helm-comint-input-ring)
	 ;;	 (define-key minibuffer-local-map (kbd "C-c C-l") 'helm-minibuffer-history))

#+END_SRC
**** Linum - line numbers
#+BEGIN_SRC emacs-lisp
	;; PACKAGE: linum-mode
	;; numeração de linhas inteligentes
	(use-package linum :ensure t
	:config
	;(global-linum-mode t))
	(add-hook 'prog-mode-hook 'linum-on)
	(add-hook 'org-mode-hook (lambda () (linum-mode 0))))
#+END_SRC
**** Winner Mode - frame navigation
#+BEGIN_SRC emacs-lisp
;; PACKAGE: winner mode
;; windows history by C-c left (undo) or C-c right (redo)

(use-package winner
   :ensure t
   :init (winner-mode 1))
#+END_SRC
**** Modeline
#+BEGIN_SRC emacs-lisp
	(show-paren-mode 1)
	(global-visual-line-mode 1)
	(display-time)
	(column-number-mode 1)
	(line-number-mode 1)
	;; PACKAGE: powerline.el
	;; powering the mode line with spacemacs theme
	(add-to-list 'load-path "~/.emacs.d/lisp/spaceline")
	(use-package powerline)
	(use-package spaceline :ensure t
	:config
	(setq-default mode-line-format '("%e" (:eval (spaceline-ml-main)))))

    (use-package spaceline-config :ensure spaceline
	:config
	(spaceline-helm-mode 1)
	(spaceline-install
	 'main
	 '((buffer-modified)
	   ((remote-host buffer-id) :face highlight-face)
	   (process :when active))
	 '((selection-info :face region :when mark-active)
	   ((flycheck-error flycheck-warning flycheck-info) :when active)
	   (which-function)
	   (version-control :when active)
	   (line-column)
	   (global :when active)
	   (major-mode))))
  (setq-default
   powerline-height 24
   powerline-default-separator 'wave
   spaceline-flycheck-bullet "❖ %s")
(use-package all-the-icons)
(use-package spaceline-all-the-icons
  :config (spaceline-all-the-icons-theme))
#+END_SRC
**** Recentf: remember last visited files
#+BEGIN_SRC emacs-lisp
  ;; PACKAGE: recentf
  (use-package recentf
   :defer t
   :config
   (setq recentf-max-saved-items 200
		 recentf-max-menu-items 15))
#+END_SRC
**** Aliases
#+BEGIN_SRC emacs-lisp
(defalias 'list-buffers 'ibuffer)
(defalias 'yes-or-no-p 'y-or-n-p)
(defalias 'qrr 'query-replace-regexp)
(defalias 'evb 'eval-buffer)
(defalias 'evr 'eval-region)
#+END_SRC
**** Buffer Editing
#+BEGIN_SRC emacs-lisp
(put 'upcase-region 'disabled nil)
(put 'downcase-region 'disabled nil)
(put 'capitalize-region 'disabled nil)
(setq x-select-enable-clipboard t) ;; clipboard on
(setq interprogram-past-function 'x-cut-buffer-or-selection-value)
(setq echo-keystrokes 0.1)

;; ibuffer everywhere
(global-set-key (kbd "C-x C-b") 'ibuffer)
(setq ibuffer-use-other-window t) ;; always display ibuffer in another window
(add-hook 'ibuffer-hook
	  (lambda ()
		(ibuffer-vc-set-filter-groups-by-vc-root)
		(unless (eq ibuffer-sorting-mode 'alphabetic)
		  (ibuffer-do-sort-by-alphabetic))))

(setq ibuffer-formats
	  '((mark modified read-only vc-status-mini " "
		  (name 18 18 :left :elide)
		  " "
		  (size 9 -1 :right)
		  " "
		  (mode 16 16 :left :elide)
		  " "
		  (vc-status 16 16 :left)
		  " "
		  filename-and-process)))

#+END_SRC

**** Shell pop
#+BEGIN_SRC emacs-lisp
  ;; PACKAGE: shell-pop.el
  ;; terminal popup (:

  (setq multi-term-program "/bin/zsh")
  (add-hook 'term-mode-hook
			(lambda ()
			  (setq term-buffer-maximum-size 10000)))
  (add-hook 'term-mode-hook
			(lambda ()
			  (setq show-trailing-whitespace nil)))

  (autoload 'multi-term "multi-term" nil t)
  (autoload 'multi-term-next "multi-term" nil t)
  (defcustom term-unbind-key-list
	'("C-z" "C-x" "C-c" "C-h" "C-y" "<ESC>")
	"The key list that will need to be unbind."
	:type 'list
	:group 'multi-term)
  (defcustom term-bind-key-alist
	'(
	  ("C-c C-c" . term-interrupt-subjob)
	  ("C-p" . previous-line)
	  ("C-n" . next-line)
	  ("C-s" . isearch-forward)
	  ("C-r" . isearch-backward)
	  ("C-m" . term-send-raw)
	  ("M-f" . term-send-forward-word)
	  ("M-b" . term-send-backward-word)
	  ("M-o" . term-send-backspace)
	  ("M-p" . term-send-up)
	  ("M-n" . term-send-down)
	  ("M-M" . term-send-forward-kill-word)
	  ("M-N" . term-send-backward-kill-word)
	  ("M-r" . term-send-reverse-search-history)
	  ("M-," . term-send-input)
	  ("M-." . comint-dynamic-complete))
	"The key alist that will need to be bind.
  If you do not like default setup, modify it, with (KEY . COMMAND) format."
	:type 'alist
	:group 'multi-term)

  (add-hook 'term-mode-hook
			(lambda ()
			  (define-key term-raw-map (kbd "C-y") 'term-paste)))

  (use-package shell-pop
   :config
   (custom-set-variables
   ;; custom-set-variables was added by Custom.
   ;; If you edit it by hand, you could mess it up, so be careful.
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   '(shell-pop-default-directory "/Users/kyagi/git")
   '(shell-pop-shell-type (quote ("multi-term" "*multi-term*" (lambda nil (ansi-term shell-pop-term-shell)))))
   '(shell-pop-term-shell "/bin/zsh")
   '(shell-pop-universal-key "C-c t")
   '(shell-pop-window-size 30)
   '(shell-pop-full-span t)
   '(shell-pop-window-position "top")))
#+END_SRC
**** Electric Pair: auto complete for 'pars chars'
#+BEGIN_SRC emacs-lisp
;; PACKAGE: eletric-pair.mode
;; Auto-complete of symbols like (), {}, []
;(electric-pair-mode 1) ;; novo auto pair
;; make electric-pair-mode work on more brackets
(setq electric-pair-pairs '(
							(?\" . ?\")
							(?\{ . ?\})
							) )
#+END_SRC

**** Uniquify: unique buffer names
#+BEGIN_SRC emacs-lisp
(use-package uniquify
  :config
  (setq uniquify-buffer-name-style 'post-forward-angle-brackets))
#+END_SRC

**** Abbrevs

#+BEGIN_SRC emacs-lisp
  (setq abbrev-file-name "~/.emacs.d/data/abbrev_defs") ;; database of abbrevs
  (setq abbrev-mode t
		save-abbrevs t)
  (when (file-exists-p abbrev-file-name)
	(quietly-read-abbrev-file))
  (add-hook 'kill-emacs-hook
			'write-abbrev-file)
  ;; hippie-expand is as better version of dabbrev-expand.
  ;; While dabbrev-expand searches fo words you already types, in current;; buffers and others buffer , hippie-expands includes more sources.
  ;; such as filenames. kill ring...
  (setq
   hippie-expand-try-functions-list
   '(try-expand-dabbrev ;; try to expand word dynamically, searching the current buffer.
	 try-expand-dabbrev-all-buffers ;; try to expand word dynamically, searching all other buffers
	 try-expand-dabbrev-from-kill ;; try to expand word dynamically, searching the kill ring
	 try-complete-file-name-partially ;; try to compelte text as a file name, as many characters as unique
	 try-complete-file-name ;; tryu to complete text as file name.
	 try-expand-all-abbrevs ;; try to expand word before point according ot all abbrev tables
	 try-expand-list ;; try to coimplete the cuyrrent line to an entire line in the buffer
	 try-expand-line ;; try to complete teh current line to an entire line in the buffer
	 try-complete-lisp-symbol-partially ;; try to coimplete as an emacs lisp symbol,
	 try-complete-lisp-symbol))
  (global-set-key (kbd "M-/") 'hippie-expand) ;; replace dabbrev-expand
  (use-package expand-region
   :config
   (global-key-binding (kbd "M-m") 'er/expand-region))
#+END_SRC
**** Undo Tree
#+BEGIN_SRC emacs-lisp
;; PACKAGE: undo-tree
;; visualize all the undo things done in a buffer in a tree view like
  (use-package undo-tree
	:ensure undo-tree
	:diminish undo-tree-mode
	:init
	(progn
	  (global-undo-tree-mode)
	  (setq undo-tree-visualizer-timestamps t)
	  (setq undo-tree-visualizer-diff t)))
#+END_SRC
**** Terminal Configuration
#+BEGIN_SRC emacs-lisp
(add-hook 'term-mode-hook       ;because of autopair
  #'(lambda () (setq autopair-dont-activate t)))
#+END_SRC
**** Dimish: less names in modeline
#+BEGIN_SRC emacs-lisp
(when (require 'diminish nil 'noerror)
  (eval-after-load "yas"
	'(diminish 'yas/minor-mode "yaS"))
  (eval-after-load "autopair"
	'(diminish 'autopair-mode "()")))
(eval-after-load 'simple
	'(progn
	   ;; diminish auto-fill-mode
	   (diminish 'auto-fill-function)
	   (diminish 'visual-line-mode)))
(when (require 'diminish nil 'noerror)
  (eval-after-load "company"
	  '(diminish 'company-mode "®")) ;; trademark symbol = company
  (eval-after-load "abbrev"
	'(diminish 'abbrev-mode "𝒶"))
 (eval-after-load "helm"
	'(diminish 'helm-mode "𝒽"))
 (eval-after-load "Irony"
	'(diminish 'irony-mode "𝒾"))
(add-hook 'emacs-lisp-mode-hook
  (lambda()
	(setq mode-name "𝝐")))
(add-hook 'auto-fill-mode-hook
  (lambda()
	(setq mode-name "𝜑")))) ;; phi de fill hihih
#+END_SRC
**** Highlight ()
#+BEGIN_SRC emacs-lisp
	 (add-hook 'highlight-parentheses-mode-hook
		  '(lambda ()
			 (setq autopair-handle-action-fns
				   (append
					(if autopair-handle-action-fns
						autopair-handle-action-fns
					  '(autopair-default-handle-action))
					'((lambda (action pair pos-before)
						(hl-paren-color-update)))))))

(define-globalized-minor-mode global-highlight-parentheses-mode
  highlight-parentheses-mode
  (lambda ()
	(highlight-parentheses-mode t))
  global-highlight-parentheses-mode t)
#+END_SRC

**** CTags :OFF:
#+BEGIN_SRC emacs-lisp
  ;;  (setq path-to-ctags "/usr/bin/ctags"); <-- your ctags path here
  ;;   (defun create-tags (dir-name)
  ;; 	 "Create tags file."
  ;; 	 (interactive "DDirectory: ")
  ;; 	 (eshell-command
  ;; 	  (format "find %s -type f -name \"*.[ch]\" | etags -" dir-name)))

  ;; (defadvice find-tag (around refresh-etags activate)
  ;;    "Rerun etags and reload tags if tag not found and redo find-tag.
  ;;    If buffer is modified, ask about save before running etags."
  ;;   (let ((extension (file-name-extension (buffer-file-name))))
  ;; 	(condition-case err
  ;; 	ad-do-it
  ;; 	  (error (and (buffer-modified-p)
  ;; 		  (not (ding))
  ;; 		  (y-or-n-p "Buffer is modified, save it? ")
  ;; 		  (save-buffer))
  ;; 		 (er-refresh-etags extension)
  ;; 		 ad-do-it))))

  ;;   (defun er-refresh-etags (&optional extension)
  ;;   "Run etags on all peer files in current dir and reload them silently."
  ;;   (interactive)
  ;;   (shell-command (format "etags *.%s" (or extension "el")))
  ;;   (let ((tags-revert-without-query t))  ; don't query, revert silently
  ;; 	(visit-tags-table default-directory nil)))
#+END_SRC
**** Visual Bookmarks using mouse
#+BEGIN_SRC emacs-lisp
;; PACKAGE: bm
;; visual bookmarks
(use-package bm
 :config
;; um clica na margem (onde tem o número de linha) e bookmark aquela linha
;; utiliza o botão de rolagem do mouse para andar entre os bookmarks.
(global-set-key (kbd "<left-fringe> <mouse-5>") 'bm-next-mouse)
(global-set-key (kbd "<left-fringe> <mouse-4>") 'bm-previous-mouse)
(global-set-key (kbd "<left-fringe> <mouse-1>") 'bm-toggle-mouse))
#+END_SRC
**** Clipboard
#+BEGIN_SRC emacs-lisp
;; Save whatever’s in the current (system) clipboard before
;; replacing it with the Emacs’ text.
;; https://github.com/dakrone/eos/blob/master/eos.org
(setq save-interprogram-paste-before-kill t)
#+END_SRC
**** Desktop Save
saving the last frame/windows/buffers configurations
#+BEGIN_SRC emacs-lisp

;; from https://github.com/dakrone/eos/blob/master/eos-core.org
;;(desktop-save-mode 1)
(setq desktop-restore-eager 1)
(setq desktop-files-not-to-save "\\(^/[^/:]*:\\|(ftp)$\\|KILL\\)")
(setq desktop-restore-frames nil)

;; use only one desktop
(setq desktop-path '("~/.emacs.d/"))
(setq desktop-dirname "~/.emacs.d/")
(setq desktop-base-file-name "emacs-desktop")

;;
;; found in  https://www.emacswiki.org/emacs/Desktop
;; remove desktop after it's been read
(add-hook 'desktop-after-read-hook
	  '(lambda ()
	     ;; desktop-remove clears desktop-dirname
	     (setq desktop-dirname-tmp desktop-dirname)
	     (desktop-remove)
	     (setq desktop-dirname desktop-dirname-tmp)))

(defun saved-session ()
  (file-exists-p (concat desktop-dirname "/" desktop-base-file-name)))

;; use session-restore to restore the desktop manually
(defun session-restore ()
  "Restore a saved emacs session."
  (interactive)
  (if (saved-session)
      (desktop-read)
    (message "No desktop found.")))

;; use session-save to save the desktop manually
(defun session-save ()
  "Save an emacs session."
  (interactive)
  (if (saved-session)
      (if (y-or-n-p "Overwrite existing desktop? ")
	  (desktop-save-in-desktop-dir)
	(message "Session not saved."))
  (desktop-save-in-desktop-dir)))

;; ask user whether to restore desktop at start-up
(add-hook 'after-init-hook
	  '(lambda ()
	     (if (saved-session)
		 (if (y-or-n-p "Restore desktop? ")))))
#+END_SRC
**** goodbye, suspend fucking frame
#+BEGIN_SRC emacs-lisp

(global-unset-key (kbd "C-z"))
(global-set-key (kbd "C-z C-z") 'my-suspend-frame)
(defun my-suspend-frame ()
  "In a GUI environment, do nothing; otherwise `suspend-frame'."
  (interactive)
  (if (display-graphic-p)
      (message "suspend-frame disabled for graphical displays.")
    (suspend-frame)))
#+END_SRC

*** Editing file
**** Searching
#+BEGIN_SRC emacs-lisp
 (setq search-default-mode #'char-fold-to-regexp)
#+END_SRC
Uses swiper instead of isearch
#+BEGIN_SRC emacs-lisp
;; [#keybinding]
  (global-set-key "\C-r" 'swiper)
  (global-set-key "\C-s" 'swiper)
#+END_SRC
**** Align by whitespace
#+BEGIN_SRC emacs-lisp
(defun align-whitespace (start end)
  "Align columns by whitespace"
  (interactive "r")
  (align-regexp start end
				"\\(\\s-*\\)\\s-" 1 0 t))
#+END_SRC
**** Mark Ring
#+BEGIN_SRC emacs-lisp
(setq global-mark-ring-max 5000
	  mark-ring-max 5000
	  mode-require-final-newline t
	  )
#+END_SRC
**** Indentation e newline

#+BEGIN_SRC emacs-lisp
  (setq c-default-style "linux";; linux style baby
		  c-basic-offset 4
		  tab-width      4)
  ;;(global-set-key (kbd "RET") 'newline-and-indent)

  ;; PACKAGE: clean-indent-mode

  ;; remove tralling whitespace
  (use-package clean-aindent-mode
  :config
  (add-hook 'prog-mode-hook 'clean-aindent-mode))

  ;; PACKAGE: dtrt-indent
  ;; maitain indentation for files

  (use-package dtrt-indent
   :diminish
   :config
   (dtrt-indent-mode 1)
   (setq dtrt-indent-verbosity 0))          ;turn off anoying message about identation

  ;; PACKAGE: ws-butler trim spaces from the end of line
  (use-package ws-butler
  :config
  (add-hook 'c-mode-common-hook 'ws-butler-mode))

  ;; show unncessary whitespace that can mess up your diff
  (add-hook 'prog-mode-hook
  (lambda () (interactive) (setq show-trailing-whitespace 1)))

  ;; set appearance of a tab that is represented by 4 spaces
  (setq-default tab-width 4)
  (delete-selection-mode)
#+END_SRC
**** Kill ring
#+BEGIN_SRC emacs-lisp
(setq kill-ring-max 5000                     ;increase kill ring capacity
	  kill-whole-line t)                     ;if NIL, kil lwhole line and ove the next line up
#+END_SRC

**** Defuns editing text files
#+BEGIN_SRC emacs-lisp
  (defcustom prelude-indent-sensitive-modes
    '(coffee-mode python-mode slim-mode haml-mode yalm-mode)
    "Modes for whith auto-indenting is suppressed."
    :type 'list)

  (defun kill-default-buffer ()
    "Kill the currently active buffer -- set to C-x so that users are not asked which buffer they want to kill."
    (interactive)
    (let (kill-buffer-query-functions) (kill-buffer)))

  ;;smart openline
  (defun prelude-smart-open-line (arg)
    "Insert an empty line after the current line.
   Position the cursor at its beginning, according to the current mode
   With a prefix ARG open line above the current line."
    (interactive "P")
    (if arg
        (prelude-smart-open-line-above)
      (progn
        (move-end-of-line nil)
        (newline-and-indent))))

;; [#keybinding]
  (global-set-key (kbd "C-x k") 'kill-default-buffer)
  (global-set-key (kbd "C-o") 'prelude-smart-open-line)


#+END_SRC
**** Smart parens
#+BEGIN_SRC emacs-lisp
  ;; PACKAGE: smartparens-config
  (use-package smartparens-config
    :diminish smartparens-mode
	:config
	(setq sp-base-key-bindings 'paredit)
	(setq sp-autoskip-closing-pair 'always)
	(setq sp-hybrid-kill-entire-symbol nil)
	(sp-use-smartparens-bindings)
	(show-smartparens-global-mode 1)
	(smartparens-global-mode 1))

  ;; whenr press RET, the curly braces automatically
  ;; add another newline
  (sp-with-modes '(c-mode c++mode)
				 (sp-local-pair "{" nil :post-handlers '(("||\n[i]" "RET")))
				 (sp-local-pair "/*" "*/" :post-handlers '((" | " "SPC")
															   ("* ||\n[i]" "RET"))))
#+END_SRC

**** Revert Mode - para quando merda acontece
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode)
#+END_SRC
**** Highlight current line
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode)
#+END_SRC
**** Multiples cursors
#+BEGIN_SRC emacs-lisp
;; PACKAGE: multiple-cursors with mouse-
(use-package multiple-cursors
 :config
(global-unset-key (kbd "M-<down-mouse-1>"))
(global-set-key (kbd "M-<mouse-1>") 'mc/add-cursor-on-click))
#+END_SRC
**** :OFF: Typing speed
:OFF: because it`s pretty lame `
#+BEGIN_SRC emacs-lisp
(require 'speed-type)
#+END_SRC
**** Markdown mode
#+BEGIN_SRC emacs-lisp
;; PACKAGE: markdown mode
(use-package markdown-mode
 :config
(add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
(add-to-list 'auto-mode-alist  '("\\.md\\'" . markdown-mode)))
#+END_SRC
**** Ispell + Abbrev
#+BEGIN_SRC emacs-lisp
  (setq save-abbrevs 'silently)
  (setq-default abbrev-mode t)
#+END_SRC
**** Hungry Delete
Delete space (no matter how much) with Ctrl+D
#+BEGIN_SRC emacs-lisp
(use-package hungry-delete
 :diminish hungry-delete-mode
 :config
 (global-hungry-delete-mode))
#+END_SRC
**** Fast searching with Swiper (helm backend)

#+END_SRC
**** Creating parent directory
Function i found in
https://iqbalansari.github.io/blog/2014/12/07/automatically-create-parent-directories-on-visiting-a-new-file-in-emacs/
#+BEGIN_SRC emacs-lisp
(defun my-create-non-existent-directory ()
      (let ((parent-directory (file-name-directory buffer-file-name)))
        (when (and (not (file-exists-p parent-directory))
                   (y-or-n-p (format "Directory `%s' does not exist! Create it?" parent-directory)))
          (make-directory parent-directory t))))
(add-to-list 'find-file-not-found-functions 'my-create-non-existent-directory)
#+END_SRC
**** pdf
***** pdf view > docview for pdf
#+BEGIN_SRC emacs-lisp
(pdf-tools-install)
#+END_SRC
***** scroll other window
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/lisp/misc/scroll-other-window")
  (require 'scroll-other-window)
  (defvar-local sow-scroll-up-command nil)
  (defvar-local sow-scroll-down-command nil)
  (defvar sow-mode-map
	(let ((km (make-sparse-keymap)))
	  (define-key km [remap scroll-other-window] 'sow-scroll-other-window)
	  (define-key km [remap scroll-other-window-down] 'sow-scroll-other-window-down)
	  km)
	"Keymap used for `sow-mode'.")

  (define-minor-mode sow-mode
	"FIXME: Not documented."
	nil nil nil
	:global t)

  (defun sow-scroll-other-window (&optional arg)
	(interactive "P")
	(sow--scroll-other-window-1 arg))

  (defun sow-scroll-other-window-down (&optional arg)
	(interactive "P")
	(sow--scroll-other-window-1 arg t))

  (defun sow--scroll-other-window-1 (n &optional down-p)
	(let* ((win (other-window-for-scrolling))
		   (cmd (with-current-buffer (window-buffer win)
				  (if down-p
					  (or sow-scroll-down-command #'scroll-up-command)
					(or sow-scroll-up-command #'scroll-down-command)))))
	  (with-current-buffer (window-buffer win)
		(save-excursion
		  (goto-char (window-point win))
		  (with-selected-window win
			(funcall cmd n))
		  (set-window-point win (point))))))

#+END_SRC
*** Buffers
**** IDO
#+BEGIN_SRC emacs-lisp
	 (ido-mode 1)
	 (setq indo-everywhere t)
     (setq ido-enable-flex-matching t)
#+END_SRC
**** Imenu (it's cool)
	 #+BEGIN_SRC emacs-lisp
	   (global-set-key (kbd "M-i") 'imenu)
	 #+END_SRC
**** Scratch Buffer
#+BEGIN_SRC emacs-lisp
;; persistent-scratch, things i put in scratch buffer will remain to the ends of time
(use-package persistent-scratch
  :config
  (persistent-scratch-setup-default))
#+END_SRC
*** Theming and visual configuration
**** Fonts and smooth scroll
#+BEGIN_SRC emacs-lisp
;;(set-frame-font  "Fantasque Sans Mono-13")  #didnt like, the k and s are strange
;; scrolling to always be a line at a time
;; (set-frame-font "InputSerif-13")
(set-frame-font "Hack-12")
(setq scroll-conservatively 10000)
#+END_SRC
**** frame title and flymake highlight
#+BEGIN_SRC emacs-lisp
;; Frame Title Bar with full path of file
(setq-default
 frame-title-format
 (list '((buffer-file-name " %f" (dired-directory
				  dired-directory
				  (revert-buffer-function " %b"
							  ("%b - dir: " default-directory)))))))

;; colors used by flymake error and warn line
(custom-set-faces
 '(flymake-errline ((((class color)) (:underline "red"))))
 '(flymake-warnline ((((class color)) (:underline "yellow")))))
#+END_SRC
**** Font Lock for keywords
#+BEGIN_SRC emacs-lisp
(add-hook 'c-mode-common-hook
			   (lambda ()
				(font-lock-add-keywords nil
				 '(("\\<\\(FIXME\\|TODO\\|BUG\\|HACK\\|TIP\\|FUCKOFF\\|FEELS\\):" 1
font-lock-warning-face t)))))
#+END_SRC
**** Colors/Theme, a lot of colors
#+BEGIN_SRC emacs-lisp
(load-theme 'spacemacs-dark t)
#+END_SRC
**** Set cursor color (i hate the default color on solarized)
#+BEGIN_SRC emacs-lisp
(set-cursor-color "#c75100")
#+END_SRC
*** Programming
**** golang
***** PATH
#+BEGIN_SRC emacs-lisp
  ;; (defun set-exec-path-from-shell-PATH ()
  ;;   (let ((path-from-shell (replace-regexp-in-string
  ;;                           "[ \t\n]*$"
  ;;                           ""
  ;;                           (shell-command-to-string "$SHELL --login -i -c 'echo $PATH'"))))
  ;;     (setenv "PATH" path-from-shell)
  ;;     (setq eshell-path-env path-from-shell) ; for eshell users
  ;;     (setq exec-path (split-string path-from-shell path-separator))))

  ;; (when window-system (set-exec-path-from-shell-PATH))
  ;; (setenv "GOPATH" "/home/mvjunq/Dev/go/gocode")
  ; :TODO: feels like a hack
(add-to-list 'exec-path "/home/mvjunq/Dev/go/gocode/bin")
#+END_SRC
***** setup
#+BEGIN_SRC emacs-lisp
(defun my-go-mode-hook ()
  (setq gofmt-command "goimports") ;; instead of go-fmt
  ; Customize compile command to run go build
  (if (not (string-match "go" compile-command))
      (set (make-local-variable 'compile-command)
           "go generate && go build -v && go test -v && go vet"))
  ; Go guru
  ;(load-file "$GOPATH/src/golang.org/x/tools/cmd/guru/guru.el")
  ; Godef jump key binding
  (local-set-key (kbd "M-.") 'godef-jump)
  (local-set-key (kbd "M-*") 'pop-tag-mark))
#+END_SRC
***** company-go
#+BEGIN_SRC emacs-lisp
(require 'company)                                   ; load company mode
(require 'company-go)                                ; load company mode go
(setq company-tooltip-limit 20)                      ; bigger popup window
(setq company-idle-delay .3)                         ; decrease delay before autocompletion popup shows
(setq company-echo-delay 0)                          ; remove annoying blinking
(setq company-begin-commands '(self-insert-command)) ; start autocompletion only after typing
(add-hook 'go-mode-hook (lambda ()
                          (set (make-local-variable 'company-backends) '(company-go))
                          (company-mode)))
#+END_SRC
***** eldoc and hooks
#+BEGIN_SRC emacs-lisp
(add-hook 'go-mode-hook 'go-eldoc-setup)
(add-hook 'before-save-hook 'gofmt-before-save)
(add-hook 'go-mode-hook 'company-mode)
#+END_SRC
***** bindings
#+BEGIN_SRC emacs-lisp
(add-hook 'go-mode-hook (lambda ()
                          (local-set-key (kbd "C-c C-r") 'go-remove-unused-imports)))
#+END_SRC
**** C/C++
***** Compilation
#+BEGIN_SRC emacs-lisp

;; PACKAGE: compile
(use-package compile
 :config
 (define-key prog-mode-map [C-f5] #'compile)
 (define-key prog-mode-map [f5]
  #'endless/compile-please)
 :init
 (setq compilation-ask-about-save nil)
 (setq compilation-scroll-output 'next-error)
 (setq compilation-skip-threshold 2))

(defcustom endless/compile-window-size 105
  "Width given to the non-compilation window."
  :type 'integer
  :group 'endless)

(defun endless/compile-please (comint)
  "Compile without confirmation.
With a prefix argument, use comint-mode."
  (interactive "P")
  ;; Do the command without a prompt.
  (save-window-excursion
	(compile (eval compile-command) (and comint t)))
  ;; Create a compile window of the desired width.
  (pop-to-buffer (get-buffer "*compilation*"))
  (enlarge-window
   (- (frame-width)
	  endless/compile-window-size
	  (window-width))
   'horizontal))

(add-hook 'c-mode-hook
		   (lambda ()
		 (unless (file-exists-p "Makefile")
		   (set (make-local-variable 'compile-command)
					;; emulate make's .c.o implicit pattern rule, but with
					;; different defaults for the CC, CPPFLAGS, and CFLAGS
					;; variables:
					;; $(CC) -c -o $@ $(CPPFLAGS) $(CFLAGS) $<
			(let ((file (file-name-nondirectory buffer-file-name)))
					  (format "%s -c -o %s.o %s %s %s"
							  (or (getenv "CC") "gcc")
							  (file-name-sans-extension file)
							  (or (getenv "CPPFLAGS") "-DDEBUG=9")
							  (or (getenv "CFLAGS") "-ansi -pedantic -Wall -g")
				  file))))))
#+END_SRC
***** GDB - gnu debugger, (quase best) debugger (oi slime)
#+BEGIN_SRC emacs-lisp
;; gdb-many-windows (múltiplas janelas ao usar o gdb)
(setq
 gdb-many-windows t
 gdb-show-main t)                        ;non-nil means display souce file containing the main routine ate startup)
#+END_SRC
***** Irony Mode - backend para autocomplete
#+BEGIN_SRC emacs-lisp
(defun my-irony-mode-hook ()
  (define-key irony-mode-map [remap completion-at-point]
	'irony-completion-at-point-async)
  (define-key irony-mode-map [remap complete-symbol]
	'irony-completion-at-point-async))
(add-hook 'irony-mode-hook 'my-irony-mode-hook)
(add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)
(eval-after-load 'company
  '(add-to-list 'company-backends 'company-irony))
(add-hook 'irony-mode-hook 'company-irony-setup-begin-commands)
(add-hook 'irony-mode-hook 'irony-eldoc)
(add-hook 'c++-mode-hook 'irony-mode)
(add-hook 'c-mode-hook 'irony-mode)
(add-hook 'objc-mode-hook 'irony-mode)
#+END_SRC
****** Defuns

#+BEGIN_SRC emacs-lisp
;; (optional) bind TAB for indent or complete
(defun irony--check-expastion()
  (save-excursion
	(if (looking-at- "\\_>") t
	  (backward-char 1)
	  (if (looking-at "\\.") t
	(backward-char 1)
	(if (looking-at "->") t nil)))))

(defun irony--indent-or-complete ()
  (interactive)
  (cond ((and (not (use-region-p))
		  (irony--check-expastion))
	 (message "complete")
	 (company-complete-common))
	(t
	 (message "indent")
	 (call-interactively 'c-indent-line-or-region))))
(defun irony-mode-keys ()
  "modify keymaps used by irony-mode"

  (local-set-key (kbd "TAB") 'irony--ident-or-complete)
  (local-set-key [tab] 'irony--indent-or-complete))
(add-hook 'c-mode-common-hook 'irony-mode-keys)

;; company-quick-help (mostra ajuda em indle)
(company-quickhelp-mode 1)      ;

#+END_SRC
***** Eldoc - helpdoce no bufferline
#+BEGIN_SRC emacs-lisp
;; example: (setq c-eldoc-includes "`pkg-config gtk+-2.0 --cflags``-I./ -I../' ")
(add-to-list 'load-path "elpa/c-eldoc")
(add-hook 'c-mode-hook 'c-turn-on-eldoc-mode)
#+END_SRC
***** Auto Complete com backend do irony+company
#+BEGIN_SRC emacs-lisp
;; (optional) adds CC special commands to `company-begin-commands' in order to
;; trigger completion at interesting places, such as after scope operator
;;     std::|
(add-hook 'irony-mode-hook 'company-irony-setup-begin-commands)
(eval-after-load 'company
  '(add-to-list 'company-backends 'company-irony))
#+END_SRC

***** Flycheck+irony
#+BEGIN_SRC emacs-lisp
(use-package flycheck
 :diminish "∰" ;; volume integral :3
 :config
 (add-to-list 'flycheck-checkers 'irony))
#+END_SRC

***** Semantic mode
#+BEGIN_SRC emacs-lisp
;; PACKAGE: sematic (deja-vu?)
(use-package semantic
 :config
(global-semanticdb-minor-mode 1)
(global-semantic-idle-scheduler-mode 1)
;; add new load path
(semantic-add-system-include "/usr/local/include")
(semantic-add-system-include "~/linux/include")
(global-semantic-idle-summary-mode 1) ;; show functions args in minibuffer
(global-semantic-stickyfunc-mode 1) ;; show in the top of file the funcion you are in
(semantic-add-system-include "~/linux/kernel")
(semantic-add-system-include "~/linux/include")
(semantic-mode 1))
#+END_SRC
***** Hooks
#+BEGIN_SRC emacs-lisp
;; now i use from every programming mode
(add-hook 'prog-mode-hook
			   (lambda ()
				(font-lock-add-keywords nil
				 '(("\\<\\(FIXME\\|TODO\\|BUG\\):" 1 font-lock-warning-face t)))))
#+END_SRC
**** Emacs Lisp
***** eldoc and rainbow delimiters
#+BEGIN_SRC emacs-lisp
  ;; PACKAGE: eldoc
  ;; helpdoc in minibuffer line
  (use-package "eldoc"
    :commands turn-on-eldoc-mode
    :init
    (progn
    (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)))
  ;; rainbow delimiters:
  ;; PACKAGE: rainbow-delimiters: syntax highlight para ()
  (require 'rainbow-delimiters)
  (add-hook 'clojure-mode-hook 'rainbow-delimiters-mode)
  (add-hook 'elisp-mode-hook 'rainbow-delimiters-mode)
  (add-hook 'after-init-hook 'global-company-mode)
  (add-hook 'org-mode 'rainbow-delimiters-mode)
#+END_SRC
**** Jumping and searching code
<C-c .> = find-function-at-point
<C-c f> = find-function
#+BEGIN_SRC emacs-lisp
(define-key emacs-lisp-mode-map (kbd "C-c .") 'find-function-at-point)
(bind-key "C-c f" 'find-function)
#+END_SRC
**** TODO Python
:TODO: needs improvement
#+BEGIN_SRC emacs-lisp
;; JEDI
(use-package jedi
  :ensure t
  :init
  (add-hook 'python-mode-hook 'jedi:setup)
  (add-hook 'python-mode-hook 'jedi:ac-setup)
  (setq jedi:complete-on-dot t))
;; elpy is cool
(use-package elpy
:ensure t
:config
(elpy-enable))
;; for jedi backend
(add-to-list 'company-backends 'company-jedi)
(add-to-list 'company-backends '(company-jedi company-files))

;;flycheck with elpy, not flymake
(when (require 'flycheck nil t)
	(setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
	(add-hook 'elpy-mode-hook 'flycheck-mode))

;; pep8
(use-package py-autopep8
 :config
(add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save))
(setq-default py-split-windows-on-execute-function 'split-window-horizontally)
(setq python-shell-prompt-detect-failure-warning nil)
#+END_SRC
**** TODO Haskell
:TODO: needs improvement
***** Hasktags
Use the M-. luke!!
#+BEGIN_SRC emacs-lisp
(let ((my-cabal-path (expand-file-name "~/.cabal/bin")))
  (setenv "PATH" (concat my-cabal-path path-separator (getenv "PATH")))
  (add-to-list 'exec-path my-cabal-path))
(custom-set-variables '(haskell-tags-on-save t))
#+END_SRC

***** Indentation
#+BEGIN_SRC emacs-lisp
;;(add-to-list 'load-path "home/mvjunq/.emacs.d/lisp/misc/structured-haskell-mode/elisp/")
;;(require 'shm)
;;(add-hook 'haskell-mode-hook #'structured-haskell-mode)
#+END_SRC
***** Cabal REPL
#+BEGIN_SRC emacs-lisp
(custom-set-variables '(haskell-process-type 'cabal-repl))
#+END_SRC

***** Keybiddings
#+BEGIN_SRC emacs-lisp

;; Haskell compilation mode
(eval-after-load 'haskell-mode
  '(define-key haskell-mode-map (kbd "C-c C-o") 'haskell-compile))
(eval-after-load 'haskell-cabal
 '(define-key haskell-cabal-mode-map (kbd "C-c C-o") 'haskell-compile))
(custom-set-variables
  '(haskell-process-suggest-remove-import-lines t)
  '(haskell-process-auto-import-loaded-modules t)
  '(haskell-process-log t))
(eval-after-load 'haskell-mode '(progn
  (define-key haskell-mode-maps (kbd "C-c C-l") 'haskell-process-load-or-reload)
  (define-key haskell-mode-map (kbd "C-c C-z") 'haskell-interactive-switch)
  (define-key haskell-mode-map (kbd "C-c C-n C-t") 'haskell-process-do-type)
  (define-key haskell-mode-map (kbd "C-c C-n C-i") 'haskell-process-do-info)
  (define-key haskell-mode-map (kbd "C-c C-n C-c") 'haskell-process-cabal-build)
  (define-key haskell-mode-map (kbd "C-c C-n c") 'haskell-process-cabal)))
(eval-after-load 'haskell-cabal '(progn
  (define-key haskell-cabal-mode-map (kbd "C-c C-z") 'haskell-interactive-switch)
  (define-key haskell-cabal-mode-map (kbd "C-c C-k") 'haskell-interactive-mode-clear)
  (define-key haskell-cabal-mode-map (kbd "C-c C-c") 'haskell-process-cabal-build)
  (define-key haskell-cabal-mode-map (kbd "C-c c") 'haskell-process-cabal)))
#+END_SRC

***** GHC-mod
#+BEGIN_SRC emacs-lisp

(let ((my-cabal-path (expand-file-name "~/.cabal/bin")))
  (setenv "PATH" (concat my-cabal-path ":" (getenv "PATH")))
  (add-to-list 'exec-path my-cabal-path))
#+END_SRC

**** Web
***** Skewer Mode
"live" mode with CSS, HTML and JS files
#+BEGIN_SRC emacs-lisp
(add-hook 'js2-mode-hook 'skewer-mode)
(add-hook 'css-mode-hook 'skewer-css-mode)
(add-hook 'html-mode-hook 'skewer-html-mode)
#+END_SRC
***** web mode
#+BEGIN_SRC emacs-lisp
  (require 'web-mode)
  (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))

  ;; hooks

  (defun web-mode-hooks()
	  "Hooks for web mode"
	  (setq web-mode-markup-indent-offset 2)
	  (setq web-mode-css-indent-offset 2)
	  (setq web-mode-code-indent-offset 2)
	  (setq web-mode-enable-auto-pairing t)
      (setq web-mode-enable-css-colorization t)
	(setq web-mode-enable-current-element-highlight t))
  (add-hook 'web-mode-hook 'web-mode-hooks)

#+END_SRC
***** autocomplete for web mode
#+BEGIN_SRC emacs-lisp
(setq web-mode-ac-sources-alist
  '(("css" . (ac-source-css-property))
    ("html" . (ac-source-words-in-buffer ac-source-abbrev))))
(setq ac-js2-evaluate-calls t)
;; add library HERE
;; (setq ac-js2-external-libraries '("full/path/to/a-library.js"))
#+END_SRC
**** Zeal on point
Zeal is cool, Zeal is nice (but very slow)
#+BEGIN_SRC emacs-lisp
(global-set-key "\C-cd" 'zeal-at-point)
#+END_SRC
**** Yasnippet
#+begin_src emacs-lisp
;; PACKAGE: yasnippet
;; yet another snippet mode
(yas-global-mode 1)
#+END_SRC
**** Fycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
  :config
  (add-hook 'after-init-hook #'global-flycheck-mode)
  (eval-after-load 'flycheck
	'(custom-set-variables
	 '(flycheck-display-errors-function #'flycheck-pos-tip-error-messages)))
  (with-eval-after-load 'flycheck
	(flycheck-pos-tip-mode))
  (add-hook 'c-mode-hook 'flycheck-mode)
  (add-hook 'c++-mode-hook 'flycheck-mode)
  (eval-after-load 'flycheck
	'(add-hook 'flycheck-mode-hook #'flycheck-irony-setup))
  (setq flycheck-check-syntax-automatically '(mode-enabled save)))

#+END_SRC
***** Flycheck e helm (i hate tooltips)
#+BEGIN_SRC emacs-lisp
(use-package helm-flycheck
 :config
(define-key flycheck-mode-map (kbd "C-c ! h") 'helm-flycheck))
#+END_SRC
**** Company Mode: autocomplete on steroids
#+BEGIN_SRC emacs-lisp
  ;; PACKAGE: company-mode
  ;; auto complete feature
  (use-package company)
  (use-package cc-mode
   :config
   (add-hook 'after-init-hook 'global-company-mode)
   (setq company-backends (delete 'company-semantic company-backends))
   (define-key c-mode-map  [(tab)] 'company-complete)
   (define-key c++-mode-map  [(tab)] 'company-complete))
  ;;(add-to-list 'company-c-headers-path-user "/usr/include/c++") ;examples in user anothers headers/includes
#+END_SRC
**** Whitespace mode
#+BEGIN_SRC emacs-lisp
	 (add-hook 'prog-mode-hook (lambda () (interactive) (setq
	 show-trailing-whitespace 1)))
	 ;;active whitespace mode to view all whitespace characters
	 (global-set-key (kbd "C-c w") 'whitespace-mode)
#+END_SRC
**** Tab para autocomplete
#+BEGIN_SRC emacs-lisp
  (setq tab-always-indent 'complete)
#+END_SRC
**** :OFF: Projectile
:OFF: it's a beast, i need to learn how to manage a project.
#+BEGIN_SRC emacs-lisp
;;(projectile-global-mode)
;;(setq projectile-enable-caching t)
#+END_SRC

*** Hooks
#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace) ;; remove the dreadful trailing whitespace
  (add-hook 'text-mode-hook 'turn-on-auto-fill) ;; text mode = best place for auto fill mode
  (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+END_SRC
*** Keybindings and navigation
**** other screen
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-o") 'other-window)
#+END_SRC

#+RESULTS:
: other-window

**** Font size
#+BEGIN_SRC emacs-lisp
(bind-key "C-+" 'text-scale-increase)
(bind-key "C--" 'text-scale-decrease)
#+END_SRC
**** Move to

#+BEGIN_SRC emacs-lisp
   (defun sacha/smarter-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.
ppp
Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first.  If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
	(let ((line-move-visual nil))
	  (forward-line (1- arg))))

  (let ((orig-point (point)))
	(back-to-indentation))
	(when (= orig-point (point))
	  (move-beginning-of-line 1)))

;; remap) C-a to `smarter-move-beginning-of-line'
(global-set-key [remap move-beginning-of-line]
				'sacha/smarter-move-beginning-of-line)
#+END_SRC

**** fast navigation with <C+Shift+_> and others

#+BEGIN_SRC emacs-lisp

(setq next-line-add-newlines t) ;; in end of file, add newline with C-n

  ;; KEYBINDINGS :TODO: move to a better place (file??)
   ;; Move more quickly
  (global-set-key (kbd "C-S-n")
                  (lambda ()
                    (interactive)
                    (ignore-errors (next-line 5))))



  (global-set-key (kbd "C-S-p")
                  (lambda ()
                    (interactive)
                    (ignore-errors (previous-line 5))))

  (global-set-key (kbd "C-S-f")
                  (lambda ()
                    (interactive)
                    (ignore-errors (forward-char 5))))
  (global-set-key (kbd "C-S-b")
                  (lambda ()
                    (interactive)
                    (ignore-errors (backward-char 5))))
#+END_SRC
**** Pop to mark
from: Sasha.org config file
Handy way of getting back to previous places.
#+BEGIN_SRC emacs-lisp
(bind-key "C-x p" 'pop-to-mark-command)
(setq set-mark-command-repeat-pop t)
#+END_SRC
**** Which Key mode
Show commands after a certain key is used
#+BEGIN_SRC emacs-lisp
  ;;PACKAGE: which-key mode
  (use-package which-key
   :diminish which-key-mode
   :config
  (which-key-mode))
#+END_SRC
**** Help - guide key
from: sasha.org config file
#+BEGIN_SRC emacs-lisp
(use-package guide-key
 :diminish guide-key-mode
 :init
 (progn
 (setq guide-key/guide-key-sequence '("C-x r" "C-x 4" "C-c"))
 (guide-key-mode 1)))  ; Enable guide-key-mode
#+END_SRC

**** visible bookmarks (C-F2)
#+BEGIN_SRC emacs-lisp
(use-package bm
  :bind (("<C-f2>" . bm-toggle)
         ("<f2>" . bm-next)
         ("<S-f2>" . bm-previous)))
#+END_SRC
*** Org-mode
**** Babel things
#+BEGIN_SRC emacs-lisp
	;; for org-babel and source code
	(setq org-confirm-babel-evaluate nil
		org-src-fontify-natively t
		org-src-tab-acts-natively t)
#+END_SRC
**** org capture, best way to use todo
	 #+BEGIN_SRC emacs-lisp
       (setq org-default-notes-file "~/Org/docs/notes.org")
       (define-key global-map "\C-cc" 'org-capture)

                                               ; log done state in TODOS
       (setq org-log-done t)


                                               ; set org-capture templates
       (setq org-capture-templates
                       `(("t" "todo" entry (file+headline "~/Org/notes.org" "Task") ;; things i have to do but dont
                          "** TODO %^{Task}")
                       ("r" "read_log" entry (file+headline "~/Org/read_log.org" "Read") ;; for my reading log
                          "** %U %^{Read}")
                       ("c" "Code" entry (file+headline "~/Org/code.org" "Code and things") ;; for interest stuff when i code
                          "** [%f] => %^{%?}")))

#+END_SRC
**** dont show markup chars
#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers t)
#+END_SRC
*** Defuns
Functions i found in the interwebs (sorry for not having the
source url).
#+BEGIN_SRC emacs-lisp
;; funcao parte da mensagem de erro no minibuffer
(defun my-flymake-show-help ()
   (when (get-char-property (point) 'flymake-overlay)
	 (let ((help (get-char-property (point) 'help-echo)))
	   (if help (message "%s" help)))))

;; indent in whitespace (interative action)
(defun indent-whitespace (beg end spaces)
  "Indent region of code by N spaces"
  (interactive "r\nnEnter number of spaces: \n")
  (indent-code-rigidly beg end spaces))

;; insert date, but <C-c .> is nice
(defun insert-date ()
  "insert date at point"
  (interactive)
  (insert (format-time-string "%a %Y-%m-%d - %l:%M %p")))

;; for the old time sakes
(defun ascii-table ()
  "Print the ascii table. Based on a defun by Alex Schroeder <asc@bsiag.com>"
  (interactive)
  (switch-to-buffer "*ASCII*")
  (erase-buffer)
  (insert (format "ASCII characters up to number %d.\n" 254))
  (let ((i 0))
	(while (< i 254)
	  (setq i (+ i 1))
	  (insert (format "%4d %c\n" i i))))
  (beginning-of-buffer))

(defun eval-and-replace ()
  "Replace the preceding sexp with its value."
  (interactive)
  (backward-kill-sexp)

  (condition-case nil
	  (prin1 (eval (read (current-kill 0)))
			 (current-buffer))
	(error (message "Invalid expression")
		   (insert (current-kill 0)))))

;; edit files like sudo
(defun sudo-edit (&optional arg)
  "do sudo things"
  (interactive "p")
  (if (or arg (not buffer-file-name))
	  (find-file (concat "/sudo:root@localhost:" (ido-read-file-name "File: ")))
	(find-alternate-file (concat "/sudo:root@localhost": buffer-file-name))))

(defun increase-font-size ()
  (interactive)
  (set-face-attribute 'default
					  nil
					  :height
					  (ceiling (* 1.10
								  (face-attribute 'default :height)))))
(defun decrease-font-size ()
  (interactive)
  (set-face-attribute 'default
					  nil
					  :height
					  (floor (* 0.9
								(face-attribute 'default :height)))))

;;
;; slick copy
;;
(defadvice kill-ring-save (before slick-copy activate compile)
	  "When called interactively with no active region, copy a single line instead."
	  (interactive
	   (if mark-active (list (region-beginning) (region-end))
		 (message "Copied line")
		 (list (line-beginning-position)
			   (line-beginning-position 2)))))
(defadvice kill-region (before slick-cut activate compile)
	  "When called interactively with no active region, kill a single line instead."
	  (interactive
	   (if mark-active (list (region-beginning) (region-end))
		 (list (line-beginning-position)
			   (line-beginning-position 2)))))
#+END_SRC
*** Emacs Debugging
#+BEGIN_SRC emacs-lisp

;; for a warning
(if (version< emacs-version "24")
      'preceding-sexp
    'elisp--preceding-sexp)

  ;; configure trace on init file errors
  (setq edebug-trace t)

  ;; byte compile init files
  (defun byte-compile-init-dir ()
	"Byte-compile all your dotfiles."
	(interactive)
	(byte-recompile-directory user-emacs-directory 0))
  (defun remove-elc-on-save ()
	"If you're saving an elisp file, likely the .elc is no longer valid."
	(add-hook 'after-save-hook
			  (lambda ()
				(if (file-exists-p (concat buffer-file-name "c"))
					(delete-file (concat buffer-file-name "c"))))
			  nil
			  t))
  (add-hook 'emacs-lisp-mode-hook 'remove-elc-on-save)

  (defun indent-whole-buffer ()
	"indent whole buffer"
	(interactive)
	(delete-trailing-whitespace)
	(indent-region (point-min) (point-max) nil)
	(untabify (point-min) (point-max)))

  ;; eval buffer (init file)
  ;; found on interwebs
  (with-eval-after-load 'debug
	(defun debugger-setup-buffer (debugger-args)
	  "Initialize the `*Backtrace*' buffer for entry to the debugger.
  That buffer should be current already."
	  (setq buffer-read-only nil)
	  (erase-buffer)
	  (set-buffer-multibyte t)        ;Why was it nil ?  -stef
	  (setq buffer-undo-list t)
	  (let ((standard-output (current-buffer))
			(print-escape-newlines t)
			(print-level 8)
			(print-length 50))
		(backtrace))
	  (goto-char (point-min))
	  (delete-region (point)
					 (progn
					   (search-forward "\n  debug(")
					   (forward-line (if (eq (car debugger-args) 'debug)
										 2    ; Remove implement-debug-on-entry frame.
									   1))
					   (point)))
	  (insert "Debugger entered")
	  ;; lambda is for debug-on-call when a function call is next.
	  ;; debug is for debug-on-entry function called.
	  (pcase (car debugger-args)
		((or `lambda `debug)
		 (insert "--entering a function:\n"))
		;; Exiting a function.
		(`exit
		 (insert "--returning value: ")
		 (setq debugger-value (nth 1 debugger-args))
		 (prin1 debugger-value (current-buffer))
		 (insert ?\n)
		 (delete-char 1)
		 (insert ? )
		 (beginning-of-line))
		;; Debugger entered for an error.
		(`error
		 (insert "--Lisp error: ")
		 (prin1 (nth 1 debugger-args) (current-buffer))
		 (insert ?\n))
		;; debug-on-call, when the next thing is an eval.
		(`t
		 (insert "--beginning evaluation of function call form:\n"))
		;; User calls debug directly.
		(_
		 (insert ": ")
		 (prin1 (if (eq (car debugger-args) 'nil)
					(cdr debugger-args) debugger-args)
				(current-buffer))
		 (insert ?\n)))
	  ;; After any frame that uses eval-buffer,
	  ;; insert a line that states the buffer position it's reading at.
	  (save-excursion
		(let ((tem eval-buffer-list))
		  (while (and tem
					  (re-search-forward "^  eval-\\(buffer\\|region\\)(" nil t))
			(beginning-of-line)
			(insert (format "Error at line %d in %s: "
							(with-current-buffer (car tem)
							  (line-number-at-pos (point)))
							(with-current-buffer (car tem)
							  (buffer-name))))
			(pop tem))))
	  (debugger-make-xrefs)))

  ;; test config file without leaving emacs
  ;; found on interwebs
  (defun test-emacs ()
	(interactive)
	(require 'async)
	(async-start
	 (lambda () (shell-command-to-string
			"emacs --batch --eval \"
  (condition-case e
	  (progn
		(load \\\"~/.emacs\\\")
		(message \\\"-OK-\\\"))
	(error
	 (message \\\"ERROR!\\\")
	 (signal (car e) (cdr e))))\""))
	 `(lambda (output)
		(if (string-match "-OK-" output)
			(when ,(called-interactively-p 'any)
			  (message "All is well"))
		  (switch-to-buffer-other-window "*startup error*")
		  (delete-region (point-min) (point-max))
		  (insert output)
		  (search-backward "ERROR!")))))
#+END_SRC
